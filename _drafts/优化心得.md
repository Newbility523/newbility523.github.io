运行预算

| 帧率 | 单位耗时 |
| ---- | -------- |
| 30   | 33ms     |
| 60   | 16ms     |
| 90   | 11ms     |

以手上的项目作为例子，目前刚好能跑满30帧，耗时如下

| 项目       | 耗时 | 比例 |
| ---------- | ---- | ---- |
| 战斗状态机 | 3ms  |      |
| 逻辑定时器 | 3ms  |      |
| HUD        |      |      |
| 后处理     | 5ms  |      |
| UI         |      |      |
| 消息       |      |      |
| 网络消息   | 5ms  |      |



在优化游戏跑满 30 以及尝试往 60 帧尝试时，阻力非常大。大量不起眼的操作都会在边角快速的消耗掉手机的算力，并且想改掉它们会改动到底层的设计。所以想达到 60 帧是不太可能了，但是能重新设计游戏能跑上 60 帧，要做什么设计。

### 不要使用 XLua

XLua 框架下，任何与 Unity 的交互都是很低效的，同样的操作直接 C# 侧实现会比 Lua 快 10 倍以上。XLua 需要做大量的准备工作实现 Lua 和 Unity 的交互。



### IsNull 三思

判空是一个非常常规的操作，所以很容易让人忽略它的耗时，以至于开发中发现 NoneReference 异常时，大部分人第一做法就是补上判空。实际上这是隐藏的大坑。

1. Unity 里的判空是被重载过的，相比原生的判空耗时比例高达 10:1。假设 1 帧有 100 个判空，就已经吃掉了xxms。
2. 这里更严重的问题其实是对象声明周期的不稳定。一个环节的不稳定就能衍生到后续流程甚至是其他分支的不稳定。于是就是出现更多的判空，再次加深 IsNull 的影响。

准确的对象声明周期管理高效运作的基础。绝对不应该在定时函数 Update，FixUpdate 此类出现 IsNull。如果报了异常，首先要做的就是排查原因，而不是出暴加判空补丁。而判空的最优做法是通过用 bool 值引用状态，通过消息通知对象被清空的，判空就是用 bool 代替。



### 区分逻辑 Update 频率

游戏运行在 60 帧不代表游戏逻辑也要 60 帧运行。将游戏逻辑的 Update 抽离，通过额外的定时器触发。同时进一步限制非视野内或远距离的 Update 频率。



### Update 少用 if state

``` c#
void Update()
{
    if (state)
		{
			state = false
			// doSomeThing
		}
}
```







### 不要直接用 UGUI 类

在开发过程里，会大量美术会有一套样式预设，直接使用 UGUI 的 Image，Text 都无法高效的应用这些样式，何况后续还会有 N 代 UI 换版。所以立项最起码就应该把常用的 Image、Text 等类派生出 XX_Image、XX_Text，然后定制一版属性面板。

更重要的是，UGUI 的原生类默认开启参与 Layout 和 Mask。这两个特性是非常大的性能热点，特别是 Layout。在比较深的布局层级中，一次 LayoutRebuild 就能轻松吃掉 30 ms ，实际次数往往还不止一次。所以派生的 XX_Image、XX_Text 还能在根源上把这两个特性关掉，特别列表内的界面有需要再勾选开启就好了。



### 尽可能不使用 Layout

这里要在点一次 Layout。只要不是很复杂的布局场景，都不要使用 Layout，简单场景自己计算位置代替。怎么区分简单还是复杂呢？

1. 单层列表（包括循环列表）就是一个非常简单的布局场景
2. HUD 中等复杂的布局场景，因为大概率会有图文混排。但是 HUD 需要一直更新，也不应使用 Layout。
3. 物品 Tip，文本列表+格子列表+按钮列表，嵌套都会影响父节点尺寸的，就是复杂场景。



### 高效的协议包

协议包的耗时是最容易被忽略的，大部分游戏优化都不会提到这一点，并且协议一般是公司一直沿用下来的，都不太会认为这里有问题。而且对网络协议的正常耗时没有概念。我们可以这么理解，协议包作为游戏内的触发器，处于逻辑层的最上游，它的量级对下游的影响是呈现扇形的。再从原理分析。网络协议是纯 CPU 的运算，字节转内存值类型，那么效率是非常高的。再结合基本的 30 帧的基本要求。他的峰值耗时不应该超过 5ms。



### 分帧、异步



UI 管理要包含上下文









